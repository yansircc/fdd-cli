import { existsSync } from "node:fs";
import { mkdir, readFile, unlink, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { listPitfalls } from "./pitfall.js";
import { type ProtectRule, extractProtectRules } from "./trigger/protect.js";

const HOOKS_DIR = ".claude/hooks";
const PROTECT_HOOK_FILE = "fdd-protect.js";
const SETTINGS_FILE = ".claude/settings.json";

export interface SyncResult {
	hooksPath: string;
	rulesCount: number;
	generated: boolean;
}

/**
 * Generate Claude Code hooks from all pitfall protect triggers
 * Called after: fdd record, fdd init
 */
export async function syncProtectHooks(cwd: string): Promise<SyncResult> {
	const pitfallsDir = join(cwd, ".fdd", "pitfalls");
	const hooksDir = join(cwd, HOOKS_DIR);
	const hookPath = join(hooksDir, PROTECT_HOOK_FILE);

	// Get all pitfalls
	let pitfalls: Awaited<ReturnType<typeof listPitfalls>> = [];
	if (existsSync(pitfallsDir)) {
		pitfalls = await listPitfalls(pitfallsDir);
	}

	// Extract protect rules
	const rules = extractProtectRules(pitfalls);

	// If no protect rules, remove existing hook file (cleanup)
	if (rules.length === 0) {
		if (existsSync(hookPath)) {
			await unlink(hookPath);
		}
		return { hooksPath: hookPath, rulesCount: 0, generated: false };
	}

	// Ensure hooks directory exists
	await mkdir(hooksDir, { recursive: true });

	// Generate hook content
	const hookContent = generateHookScript(rules);

	// Write hook file
	await writeFile(hookPath, hookContent, "utf-8");

	// Ensure settings.json has hook configured
	await ensureHookSettings(cwd);

	return { hooksPath: hookPath, rulesCount: rules.length, generated: true };
}

/**
 * Ensure settings.json has the protect hook configured
 */
async function ensureHookSettings(cwd: string): Promise<boolean> {
	const settingsPath = join(cwd, SETTINGS_FILE);
	// biome-ignore lint/suspicious/noExplicitAny: settings structure is dynamic
	let settings: any = {};

	// Read existing settings
	if (existsSync(settingsPath)) {
		try {
			const content = await readFile(settingsPath, "utf-8");
			settings = JSON.parse(content);
		} catch {
			// If parse fails, start fresh
			settings = {};
		}
	}

	// Check if FDD hook already configured
	const preToolUse = settings.hooks?.PreToolUse || [];
	// biome-ignore lint/suspicious/noExplicitAny: hook structure varies
	const hasFddHook = preToolUse.some((h: any) =>
		// biome-ignore lint/suspicious/noExplicitAny: hook structure varies
		h.hooks?.some((hook: any) => hook.command?.includes("fdd-protect")),
	);

	if (hasFddHook) return false;

	// Add FDD hook configuration
	if (!settings.hooks) settings.hooks = {};
	if (!settings.hooks.PreToolUse) settings.hooks.PreToolUse = [];

	settings.hooks.PreToolUse.push({
		matcher: "Write|Edit|MultiEdit",
		hooks: [
			{
				type: "command",
				command: `node ${HOOKS_DIR}/${PROTECT_HOOK_FILE}`,
				timeout: 5,
			},
		],
	});

	await mkdir(join(cwd, ".claude"), { recursive: true });
	await writeFile(settingsPath, JSON.stringify(settings, null, 2), "utf-8");
	return true;
}

/**
 * Generate the hook script content
 */
function generateHookScript(rules: ProtectRule[]): string {
	const rulesJson = JSON.stringify(rules, null, 2);

	return `#!/usr/bin/env node
/**
 * FDD Protect Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd record
 *
 * Intercepts Write/Edit tool calls and blocks/warns based on
 * protect rules defined in .fdd/pitfalls/
 */

const { minimatch } = require("minimatch");
const fs = require("fs");
const path = require("path");

// Protect rules extracted from pitfalls
const PROTECT_RULES = ${rulesJson};

// Read input from stdin
let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    const input = JSON.parse(inputData);
    processToolCall(input);
  } catch (error) {
    // Don't block on parse errors
    process.exit(0);
  }
});

function processToolCall(input) {
  const { tool_name, tool_input } = input;
  const cwd = process.cwd();

  // Get file path from tool input
  const filePath = tool_input?.file_path || tool_input?.path || "";
  if (!filePath) {
    process.exit(0); // No file path, allow
  }

  // Normalize path (relative to cwd)
  const relativePath = filePath.startsWith("/")
    ? path.relative(cwd, filePath)
    : filePath;

  // Determine operation type
  const isCreate = !fs.existsSync(path.resolve(cwd, relativePath));
  const operation = isCreate ? "create" : "update";

  // Check against each rule
  for (const rule of PROTECT_RULES) {
    // Check if path matches any protected pattern (and not excluded)
    const matchesPath = rule.paths.some(pattern =>
      minimatch(relativePath, pattern) || minimatch(filePath, pattern)
    );

    if (!matchesPath) continue;

    // Check exclusions
    const isExcluded = rule.exclude.some(pattern =>
      minimatch(relativePath, pattern) || minimatch(filePath, pattern)
    );

    if (isExcluded) continue;

    // Check permission for this operation
    const permission = rule.permissions[operation];

    if (permission === "deny") {
      const message = rule.message ||
        \`[FDD] File "\${relativePath}" is protected by \${rule.pitfallId}: \${rule.pitfallTitle}\`;

      // Block: exit 2 with message on stderr
      console.error(\`\\nðŸš« \${message}\\n\`);
      console.error(\`   Operation: \${operation}\`);
      console.error(\`   Pitfall: \${rule.pitfallId}\\n\`);
      process.exit(2);
    }
  }

  // No match or allowed - proceed
  process.exit(0);
}
`;
}
