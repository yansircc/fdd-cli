/**
 * FDD Autocheck Hook Generator
 * Runs fdd check after file modifications
 */

import { existsSync } from "node:fs";
import { mkdir, unlink, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { Pitfall } from "../../types/index.js";
import { HOOKS_DIR, HOOK_FILES, type SyncResult } from "./types.js";

/**
 * Sync autocheck hooks
 * Generated if there are any pitfalls to check
 */
export async function syncAutocheckHook(
	cwd: string,
	pitfalls: Pitfall[],
): Promise<SyncResult> {
	const hooksDir = join(cwd, HOOKS_DIR);
	const hookPath = join(hooksDir, HOOK_FILES.autocheck);

	if (pitfalls.length === 0) {
		if (existsSync(hookPath)) {
			await unlink(hookPath);
		}
		return { hooksPath: hookPath, rulesCount: 0, generated: false };
	}

	await mkdir(hooksDir, { recursive: true });
	await writeFile(hookPath, generateScript(), "utf-8");

	return { hooksPath: hookPath, rulesCount: pitfalls.length, generated: true };
}

function generateScript(): string {
	return `#!/usr/bin/env node
/**
 * FDD Autocheck Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add
 *
 * Runs after Write/Edit tool calls to check if any pitfall triggers fired
 */

const { execSync } = require("child_process");

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    runAutocheck(JSON.parse(inputData));
  } catch (error) {
    process.exit(0);
  }
});

function runAutocheck(input) {
  const cwd = process.cwd();

  try {
    const result = execSync("fdd check --json", {
      cwd,
      encoding: "utf8",
      timeout: 25000,
      stdio: ["pipe", "pipe", "pipe"],
    });

    const checkResult = JSON.parse(result);
    const triggered = checkResult.results?.filter(r => r.triggered) || [];

    if (triggered.length > 0) {
      console.log("\\nâš ï¸  [FDD] Pitfall triggers detected after file modification:\\n");

      for (const pitfall of triggered) {
        console.log(\`â”â”â” \${pitfall.pitfallId}: \${pitfall.pitfallTitle} â”â”â”\`);
        console.log(\`   Severity: \${pitfall.severity}\`);

        const firedTriggers = pitfall.triggers?.filter(t => t.triggered) || [];
        for (const trigger of firedTriggers) {
          console.log(\`   Trigger [\${trigger.kind}]: matched\`);
          if (trigger.matches?.length > 0) {
            console.log(\`     Matches: \${trigger.matches.slice(0, 3).join(", ")}\${trigger.matches.length > 3 ? "..." : ""}\`);
          }
        }
        console.log("");
      }

      console.log("ðŸ’¡ Run 'fdd list' or check .fdd/pits/ for remediation steps.\\n");
    }
  } catch (error) {
    // Silently ignore - don't block workflow
  }

  process.exit(0);
}
`;
}
