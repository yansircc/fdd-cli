/**
 * FDD Inject Context Hook Generator
 * Injects pitfall context into Claude when AI edits certain files
 *
 * Uses PreToolUse hook with deny + permissionDecisionReason
 * to inject context before Edit/Write/MultiEdit operations
 */

import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { Pitfall } from "../../types/index.js";
import {
	type InjectContextRule,
	extractInjectContextRules,
} from "../trigger/inject-context.js";
import { HOOKS_DIR, HOOK_FILES, type SyncResult } from "./types.js";

/**
 * Sync inject-context hooks
 * Always generates hook file (empty rules = pass-through)
 */
export async function syncContextHook(
	cwd: string,
	pitfalls: Pitfall[],
): Promise<SyncResult> {
	const hooksDir = join(cwd, HOOKS_DIR);
	const hookPath = join(hooksDir, HOOK_FILES.context);

	const rules = extractInjectContextRules(pitfalls);

	await mkdir(hooksDir, { recursive: true });
	await writeFile(hookPath, generateScript(rules), "utf-8");

	return { hooksPath: hookPath, rulesCount: rules.length, generated: true };
}

function generateScript(rules: InjectContextRule[]): string {
	const rulesJson = JSON.stringify(rules, null, 2);

	return `#!/usr/bin/env node
/**
 * FDD Inject Context Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add
 *
 * PreToolUse hook that injects context before Edit/Write/MultiEdit operations
 * Uses deny + permissionDecisionReason to inject context into Claude's thinking
 */

const fs = require("fs");
const path = require("path");
const { minimatch } = require("minimatch");

const INJECT_CONTEXT_RULES = ${rulesJson};

// State file to track already-intercepted files (avoid infinite loop)
const STATE_FILE = path.join(__dirname, ".inject-state.json");

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    handlePreToolUse(JSON.parse(inputData));
  } catch (error) {
    // On error, allow the operation to continue
    outputAllow();
  }
});

function handlePreToolUse(data) {
  const toolName = data.tool_name;
  const toolInput = data.tool_input || {};

  // Only process Edit, Write, MultiEdit tools
  if (toolName !== "Edit" && toolName !== "Write" && toolName !== "MultiEdit") {
    outputAllow();
    return;
  }

  const filePath = toolInput.file_path || "";
  if (!filePath) {
    outputAllow();
    return;
  }

  // Normalize file path to relative path
  const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();
  let normalizedPath = filePath.replace(/^\\.\\//g, "");
  if (path.isAbsolute(normalizedPath)) {
    normalizedPath = path.relative(projectDir, normalizedPath);
  }

  // Find matching rules
  const matchedRules = findMatchingRules(normalizedPath);
  if (matchedRules.length === 0) {
    outputAllow();
    return;
  }

  // Check state - have we already intercepted this file?
  // Using pure path as key (no session isolation - once warned, always remembered)
  const stateKey = normalizedPath;
  const state = loadState();

  if (state[stateKey]) {
    // Already intercepted, allow
    outputAllow();
    return;
  }

  // First interception - record state and deny with context
  state[stateKey] = {
    timestamp: Date.now(),
    tool: toolName,
    pitfallIds: matchedRules.map(r => r.pitfallId)
  };
  saveState(state);

  // Build the context message (inline all context content)
  const contextMessage = buildContextMessage(matchedRules, normalizedPath);

  // Output deny with the context as reason
  outputDeny(contextMessage);
}

function findMatchingRules(filePath) {
  const matched = [];

  for (const rule of INJECT_CONTEXT_RULES) {
    let isMatch = false;

    // Check when_touching patterns
    for (const pattern of rule.whenTouching) {
      if (minimatch(filePath, pattern) || filePath.includes(pattern.replace(/\\*\\*/g, "").replace(/\\*/g, ""))) {
        isMatch = true;
        break;
      }
    }

    if (!isMatch) continue;

    // Check exclude patterns
    const isExcluded = rule.exclude.some(excl => minimatch(filePath, excl));
    if (isExcluded) continue;

    matched.push(rule);
  }

  return matched;
}

function buildContextMessage(rules, filePath) {
  const parts = [];

  parts.push(\`[FDD] 编辑 \${filePath} 前请注意以下历史问题:\\n\`);

  for (const rule of rules) {
    parts.push(\`### [\${rule.pitfallId}] \${rule.pitfallTitle}\\n\`);
    parts.push(rule.context);
    parts.push("");
  }

  parts.push("请继续编辑。");

  return parts.join("\\n");
}

function outputAllow() {
  const output = {
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "allow"
    }
  };
  console.log(JSON.stringify(output));
  process.exit(0);
}

function outputDeny(reason) {
  const output = {
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "deny",
      permissionDecisionReason: reason
    }
  };
  console.log(JSON.stringify(output));
  process.exit(0);
}

function loadState() {
  try {
    if (fs.existsSync(STATE_FILE)) {
      return JSON.parse(fs.readFileSync(STATE_FILE, "utf8"));
    }
  } catch (e) {}
  return {};
}

function saveState(state) {
  try {
    fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2));
  } catch (e) {}
}
`;
}
