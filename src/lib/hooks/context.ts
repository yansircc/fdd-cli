/**
 * FDD Context Hook Generator
 * Injects pitfall context into Claude when user mentions certain files
 */

import { existsSync } from "node:fs";
import { mkdir, unlink, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { Pitfall } from "../../types/index.js";
import {
	type AiContextRule,
	extractAiContextRules,
} from "../trigger/ai-context.js";
import { HOOKS_DIR, HOOK_FILES, type SyncResult } from "./types.js";

/**
 * Sync context hooks
 */
export async function syncContextHook(
	cwd: string,
	pitfalls: Pitfall[],
): Promise<SyncResult> {
	const hooksDir = join(cwd, HOOKS_DIR);
	const hookPath = join(hooksDir, HOOK_FILES.context);

	const rules = extractAiContextRules(pitfalls);

	if (rules.length === 0) {
		if (existsSync(hookPath)) {
			await unlink(hookPath);
		}
		return { hooksPath: hookPath, rulesCount: 0, generated: false };
	}

	await mkdir(hooksDir, { recursive: true });
	await writeFile(hookPath, generateScript(rules), "utf-8");

	return { hooksPath: hookPath, rulesCount: rules.length, generated: true };
}

function generateScript(rules: AiContextRule[]): string {
	const rulesJson = JSON.stringify(rules, null, 2);

	return `#!/usr/bin/env node
/**
 * FDD Context Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add
 *
 * Intercepts UserPromptSubmit and injects relevant context
 * based on ai-context rules defined in .fdd/pitfalls/
 */

const { minimatch } = require("minimatch");

const CONTEXT_RULES = ${rulesJson};

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    processPrompt(JSON.parse(inputData));
  } catch (error) {
    process.exit(0);
  }
});

function extractFilePaths(prompt) {
  const paths = new Set();
  const patterns = [
    /(?:^|\\s|["'\`])([\\w./\\-]+\\.(?:ts|tsx|js|jsx|json|yaml|yml|md|css|scss|html|py|go|rs|java|c|cpp|h|hpp|rb|php|sql|sh|bash|zsh))/gi,
    /(?:^|\\s|["'\`])([\\w./\\-]+\\/)/gi,
    /["'\`]([^"'\`]+\\.(?:ts|tsx|js|jsx|json|yaml|yml|md|css|scss|html|py|go|rs|java|c|cpp|h|hpp|rb|php|sql|sh|bash|zsh))["'\`]/gi,
  ];

  for (const pattern of patterns) {
    let match;
    while ((match = pattern.exec(prompt)) !== null) {
      let path = match[1].replace(/^["'\`]|["'\`]$/g, "").trim();
      if (path.startsWith("./")) path = path.slice(2);
      if (path) paths.add(path);
    }
  }
  return Array.from(paths);
}

function processPrompt(input) {
  const prompt = input.prompt || "";
  if (!prompt) process.exit(0);

  const mentionedPaths = extractFilePaths(prompt);
  const matchedContexts = [];

  for (const rule of CONTEXT_RULES) {
    let matched = false;

    for (const filePath of mentionedPaths) {
      for (const pattern of rule.whenTouching) {
        if (minimatch(filePath, pattern) || filePath.includes(pattern.replace(/\\*\\*/g, "").replace(/\\*/g, ""))) {
          const isExcluded = rule.exclude.some(excl => minimatch(filePath, excl));
          if (!isExcluded) {
            matched = true;
            break;
          }
        }
      }
      if (matched) break;
    }

    if (!matched) {
      for (const pattern of rule.whenTouching) {
        const keyPart = pattern
          .replace(/\\*\\*/g, "")
          .replace(/\\*/g, "")
          .replace(/^\\.?\\//, "")
          .replace(/\\/$/, "");
        if (keyPart && prompt.toLowerCase().includes(keyPart.toLowerCase())) {
          matched = true;
          break;
        }
      }
    }

    if (matched) {
      matchedContexts.push({
        pitfallId: rule.pitfallId,
        pitfallTitle: rule.pitfallTitle,
        pitfallFilename: rule.pitfallFilename,
      });
    }
  }

  if (matchedContexts.length > 0) {
    // 输出 @ 引用让 Claude 阅读 pitfall 文件
    for (const ctx of matchedContexts) {
      console.log(\`注意: \${ctx.pitfallTitle} → @.fdd/pitfalls/\${ctx.pitfallFilename}\`);
    }
    console.error(" ");  // 避免 "No stderr output" 警告
  }

  process.exit(0);
}
`;
}
