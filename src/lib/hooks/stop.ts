/**
 * FDD Stop Hook Generator
 * Detects file modifications and prompts for pitfall recording
 */

import { existsSync } from "node:fs";
import { mkdir, unlink, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { Pitfall } from "../../types/index.js";
import { HOOKS_DIR, HOOK_FILES, type SyncResult } from "./types.js";

/**
 * Sync stop hook
 * Always generated to detect modifications and prompt for pitfall recording
 */
export async function syncStopHook(
	cwd: string,
	_pitfalls: Pitfall[],
): Promise<SyncResult> {
	const hooksDir = join(cwd, HOOKS_DIR);
	const hookPath = join(hooksDir, HOOK_FILES.stop);

	// Always generate stop hook (for modification detection)
	await mkdir(hooksDir, { recursive: true });
	await writeFile(hookPath, generateScript(), "utf-8");

	return { hooksPath: hookPath, rulesCount: 1, generated: true };
}

/**
 * Remove stop hook
 */
export async function removeStopHook(cwd: string): Promise<void> {
	const hookPath = join(cwd, HOOKS_DIR, HOOK_FILES.stop);
	if (existsSync(hookPath)) {
		await unlink(hookPath);
	}
}

function generateScript(): string {
	return `#!/usr/bin/env node
/**
 * FDD Stop Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd record/init
 *
 * Detects file modifications and prompts Claude to consider recording pitfalls
 */

const fs = require("fs");
const path = require("path");
const os = require("os");

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    processStopHook(JSON.parse(inputData));
  } catch (error) {
    process.exit(0);
  }
});

function processStopHook(input) {
  const sessionId = input.session_id;
  const transcriptPath = input.transcript_path;

  if (!transcriptPath || !fs.existsSync(transcriptPath)) {
    process.exit(0);
  }

  // State file to prevent infinite loops
  const stateFile = path.join(os.tmpdir(), \`fdd-stop-\${sessionId}.json\`);

  let state = { lastPromptedLine: 0 };
  if (fs.existsSync(stateFile)) {
    try {
      state = JSON.parse(fs.readFileSync(stateFile, "utf8"));
    } catch (e) {}
  }

  // Read transcript
  const content = fs.readFileSync(transcriptPath, "utf8");
  const lines = content.trim().split("\\n");
  const currentLineCount = lines.length;

  // Skip if already prompted for this position
  if (state.lastPromptedLine >= currentLineCount) {
    process.exit(0);
  }

  // Check only new lines since last prompt
  const newLines = lines.slice(state.lastPromptedLine);
  const modifyTools = ["Edit", "Write", "MultiEdit"];

  let hasModification = false;
  let modifiedFiles = [];

  for (const line of newLines) {
    try {
      const entry = JSON.parse(line);

      if (entry.message?.content) {
        const contents = Array.isArray(entry.message.content)
          ? entry.message.content
          : [entry.message.content];

        for (const c of contents) {
          if (c.type === "tool_use" && modifyTools.includes(c.name)) {
            hasModification = true;
            const filePath = c.input?.file_path;
            if (filePath && !modifiedFiles.includes(filePath)) {
              // Extract relative path for cleaner output
              const cwd = process.cwd();
              const displayPath = filePath.startsWith(cwd)
                ? filePath.slice(cwd.length + 1)
                : filePath;
              modifiedFiles.push(displayPath);
            }
          }
        }
      }
    } catch (e) {}
  }

  // Update state to mark current position as processed
  state.lastPromptedLine = currentLineCount;
  fs.writeFileSync(stateFile, JSON.stringify(state), "utf8");

  if (hasModification) {
    console.error(\`
[FDD] 检测到文件修改，请反思是否值得记录坑位：

修改的文件: \${modifiedFiles.slice(0, 5).join(", ")}\${modifiedFiles.length > 5 ? " ..." : ""}

判断标准：
1. 这是"修复"操作吗？（bug fix / 问题解决）
2. 能设计自动 trigger → 记录为 pitfall (rule/change/dynamic)
3. 不能自动 trigger → 记录为 ai-context (文件 note)

如果值得记录，请主动询问用户。
\`);
    process.exit(2);  // Trigger Claude to continue
  } else {
    process.exit(0);  // Silent exit
  }
}
`;
}
