/**
 * FDD Session Init Hook Generator
 * Clears inject-context state file at session start
 *
 * This ensures each new session gets fresh context injection reminders
 * while avoiding state file bloat and repeated reminders within the same session
 */

import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { HOOKS_DIR, HOOK_FILES, type SyncResult } from "./types.js";

/**
 * Sync session-init hook
 * Always generates the hook (no pitfall dependency)
 */
export async function syncSessionInitHook(cwd: string): Promise<SyncResult> {
	const hooksDir = join(cwd, HOOKS_DIR);
	const hookPath = join(hooksDir, HOOK_FILES.sessionInit);

	await mkdir(hooksDir, { recursive: true });
	await writeFile(hookPath, generateScript(), "utf-8");

	return { hooksPath: hookPath, rulesCount: 1, generated: true };
}

function generateScript(): string {
	return `#!/usr/bin/env node
/**
 * FDD Session Init Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd init/add
 *
 * SessionStart hook that clears inject-context state file
 * Ensures fresh context injection reminders for each new session
 */

const fs = require("fs");
const path = require("path");

const STATE_FILE = path.join(__dirname, ".inject-state.json");

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    // Clear the inject-context state file
    if (fs.existsSync(STATE_FILE)) {
      fs.unlinkSync(STATE_FILE);
    }

    // Output success (optional context for Claude)
    const output = {
      hookSpecificOutput: {
        hookEventName: "SessionStart"
      }
    };
    console.log(JSON.stringify(output));
    process.stderr.write(" ");
    process.exit(0);
  } catch (error) {
    // On error, continue anyway (don't block session start)
    process.stderr.write(" ");
    process.exit(0);
  }
});
`;
}
