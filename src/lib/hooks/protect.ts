/**
 * FDD Protect Hook Generator
 * Intercepts Write/Edit tool calls and blocks based on protect rules
 */

import { existsSync } from "node:fs";
import { mkdir, unlink, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { Pitfall } from "../../types/index.js";
import { type ProtectRule, extractProtectRules } from "../trigger/protect.js";
import { HOOKS_DIR, HOOK_FILES, type SyncResult } from "./types.js";

/**
 * Sync protect hooks
 */
export async function syncProtectHook(
	cwd: string,
	pitfalls: Pitfall[],
): Promise<SyncResult> {
	const hooksDir = join(cwd, HOOKS_DIR);
	const hookPath = join(hooksDir, HOOK_FILES.protect);

	const rules = extractProtectRules(pitfalls);

	if (rules.length === 0) {
		if (existsSync(hookPath)) {
			await unlink(hookPath);
		}
		return { hooksPath: hookPath, rulesCount: 0, generated: false };
	}

	await mkdir(hooksDir, { recursive: true });
	await writeFile(hookPath, generateScript(rules), "utf-8");

	return { hooksPath: hookPath, rulesCount: rules.length, generated: true };
}

function generateScript(rules: ProtectRule[]): string {
	const rulesJson = JSON.stringify(rules, null, 2);

	return `#!/usr/bin/env node
/**
 * FDD Protect Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add
 *
 * Intercepts Write/Edit tool calls and blocks/warns based on
 * protect rules defined in .fdd/pits/
 */

const { minimatch } = require("minimatch");
const fs = require("fs");
const path = require("path");

const PROTECT_RULES = ${rulesJson};

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    processToolCall(JSON.parse(inputData));
  } catch (error) {
    process.exit(0);
  }
});

function processToolCall(input) {
  const { tool_input } = input;
  const cwd = process.cwd();

  const filePath = tool_input?.file_path || tool_input?.path || "";
  if (!filePath) process.exit(0);

  const relativePath = filePath.startsWith("/")
    ? path.relative(cwd, filePath)
    : filePath;

  const isCreate = !fs.existsSync(path.resolve(cwd, relativePath));
  const operation = isCreate ? "create" : "update";

  for (const rule of PROTECT_RULES) {
    const matchesPath = rule.paths.some(pattern =>
      minimatch(relativePath, pattern) || minimatch(filePath, pattern)
    );
    if (!matchesPath) continue;

    const isExcluded = rule.exclude.some(pattern =>
      minimatch(relativePath, pattern) || minimatch(filePath, pattern)
    );
    if (isExcluded) continue;

    const permission = rule.permissions[operation];
    if (permission === "deny") {
      const message = rule.message ||
        \`[FDD] File "\${relativePath}" is protected by \${rule.pitfallId}: \${rule.pitfallTitle}\`;
      console.error(\`\\nðŸš« \${message}\\n\`);
      console.error(\`   Operation: \${operation}\`);
      console.error(\`   Pitfall: \${rule.pitfallId}\\n\`);
      process.exit(2);
    }
  }

  process.exit(0);
}
`;
}
