/**
 * FDD Guard Hook Generator
 * Intercepts Bash commands and checks against command triggers
 */

import { existsSync } from "node:fs";
import { mkdir, unlink, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { Pitfall } from "../../types/index.js";
import { HOOKS_DIR, HOOK_FILES, type SyncResult } from "./types.js";

/**
 * Sync guard hooks
 * Generated if there are any command triggers
 */
export async function syncGuardHook(
	cwd: string,
	pitfalls: Pitfall[],
): Promise<SyncResult> {
	const hooksDir = join(cwd, HOOKS_DIR);
	const hookPath = join(hooksDir, HOOK_FILES.guard);

	const hasCommandTriggers = pitfalls.some((p) =>
		p.trigger?.some((t) => t.kind === "command"),
	);

	if (!hasCommandTriggers) {
		if (existsSync(hookPath)) {
			await unlink(hookPath);
		}
		return { hooksPath: hookPath, rulesCount: 0, generated: false };
	}

	await mkdir(hooksDir, { recursive: true });
	await writeFile(hookPath, generateScript(), "utf-8");

	const commandTriggerCount = pitfalls.reduce(
		(count, p) =>
			count + (p.trigger?.filter((t) => t.kind === "command").length || 0),
		0,
	);

	return {
		hooksPath: hookPath,
		rulesCount: commandTriggerCount,
		generated: true,
	};
}

function generateScript(): string {
	return `#!/usr/bin/env node
/**
 * FDD Guard Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add
 *
 * Intercepts Bash tool calls and checks against command triggers
 */

const { execSync } = require("child_process");

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    checkCommand(JSON.parse(inputData));
  } catch (error) {
    process.exit(0);
  }
});

function checkCommand(input) {
  const { tool_name, tool_input } = input;

  if (tool_name !== "Bash") process.exit(0);

  const command = tool_input?.command || "";
  if (!command) process.exit(0);

  // Skip fdd commands to avoid recursion
  if (command.trim().startsWith("fdd ")) process.exit(0);

  const cwd = process.cwd();

  try {
    execSync(\`fdd guard "\${command.replace(/"/g, '\\\\"')}"\`, {
      cwd,
      encoding: "utf8",
      timeout: 5000,
      stdio: ["pipe", "pipe", "inherit"],
    });
    process.exit(0);
  } catch (error) {
    if (error.status === 1) {
      console.error("\\nüö´ [FDD] Command blocked by pitfall rule.\\n");
      process.exit(2);
    } else if (error.status === 2) {
      console.log("\\n‚ö†Ô∏è  [FDD] Command triggered a warning but will proceed.\\n");
      process.exit(0);
    } else {
      process.exit(0);
    }
  }
}
`;
}
