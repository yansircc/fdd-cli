# AI 编程的尽头，是让代码库学会“看自己的死法”

昨晚我又被《只狼》教育了。

那种教育不是“你不够强”，而是“你不长记性”。你在同一个转角被偷袭三次，BOSS 的第一刀永远是你最熟悉的一刀——熟悉到你甚至能背出台词，但还是会死。

后来我注意到地上的绿色影子：点一下，就能看到别人是怎么死的。更关键的是——你会看到**自己**上一次是怎么死的。它不解释、不说教，就把死亡过程完整回放一遍。

你一瞬间明白：原来坑在这里。下一次，你会提前抬刀。

关掉游戏，我突然意识到：**这不就是我们现在做 AI 编程最缺的东西吗？**

---

## 1. 这个时代最普遍的“编程现象”：AI 写得快，但它教不会

用 Cursor、Claude、各类 Agent 写代码的人，最近都会遇到一种新型崩溃：

* 你给它个任务，它啪啪啪写完；
* 你一跑，全是错；
* 你指出错误，它态度极好：“对不起，我疏忽了”；
* 它立刻改，反手又改出一个新错；
* 更气人的是：**它会在别的模块里，重复犯同样的错。**

于是大家做两件事：

1. 调 Prompt
2. 换更贵的模型

但效果往往只是“好一点”，离“可靠”还差得远。

因为这件事的问题，不在模型参数里，而在它的工作方式里。

---

## 2. AI 不是没智商，而是没记忆

我们以前写代码，报错是给人看的。人类的优势是：**能记住昨天踩过的坑**。

AI 不行。

AI 的“记忆”几乎完全依赖当前上下文（context）。对话一长，它就断片；session 一换，它就归零；你昨天教过它的东西，今天它像没听过一样再犯一遍。

这不是“笨”，而是结构性限制：
**它不像一个会成长的徒弟，更像一条只有几秒钟记忆的鱼。**

而编程真正昂贵的，不是“写出来”，是：

* **在巨大代码库里搜索原因（搜不到）**
* **在模糊反馈里做推断（猜不准）**
* **在上下文耗尽后重来一遍（忘得快）**

如果你只给它一条传统报错：

> `TypeError: undefined is not a function`

那你等于把它扔进黑暗，让它自己摸墙。摸着摸着，就开始“合理化”——也就是我们说的幻觉。

---

## 3. 把报错写得更好，仍然救不了“失忆症”

很多人开始改进报错：加更多提示、贴更多链接、输出更长日志。确实有用，但很快会遇到一个上限：

* 今天你修好了；
* 下次遇到同类问题，Agent 仍然要重新推理；
* 上下文一旦换了，它又像第一次见到这个坑。

也就是说：**报错提示只能帮助“当下”，不能形成“长期经验”。**

你能想象一个游戏，如果你每次死了，系统只弹出一句话：

> “你死了，请注意敌人的攻击。”

这当然没用。你需要的是回放。

---

## 4. FDD 不是教 AI 写代码，而是教代码库记住失败

为了解决上面的问题，我们需要一套全新的范式。

我把这套方法叫 **FDD：反馈驱动开发（Feedback-Driven Development）**。

但我要先撕开一个误解：
FDD 不是“写更好的报错提示”。那只是表皮。

**真正的 FDD，是为代码库装上一套“项目经验系统”——让它能记住失败，能回放失败，能引导自愈。**

一句话概括：

> **AI 会忘，但 Repo 不会。
> 我们要把经验从 AI 的脑子里，迁移到代码库的结构里。**

这就像《只狼》的影子：你不需要记住每次怎么死的——地上已经帮你记住了。

---

## 5. 一个“项目经验系统”到底长什么样？

任何“经验系统”必须完成四件事，缺一不可：

1. **Trigger：怎么检测到又踩坑了？**
2. **Replay：把上次怎么死的回放给你看**
3. **Action：怎么爬出来**
4. **Verify：怎么确认修好了？**

注意这里最关键的变化：

> FDD 的核心不是 Error，而是 Trigger。
> 你得先能在"犯错的一瞬间"知道错了，经验才能被触发。

所以 FDD 的结构是：

```
.fdd/
  detectors/   # 发现你又要死了
  replays/     # 回放你上次怎么死的
  remedies/    # 怎么爬出来：脚本/文档/工具/变换
  index.yaml   # 把它们关联成闭环
```

---

## 6. 最难的不是"怎么修"，而是"怎么触发经验"

很多人说：“经验我懂，写文档就行。”

不行。

经验如果只是文档，它只能在你“已经死了”之后才想起来翻一翻。随着文档越来越多，多到超过 content 窗口，Agent 更不会主动翻。它会直接继续猜，继续改，继续错。

要让它像导航一样工作，你必须解决一个问题：

> **如何在犯错的一瞬间触发经验回放？**

也就是：**自触发（Self-trigger）**。如果触发失败，FDD 会退化成"收藏夹"。

---

## 7. Trigger 不是一种技术，是一张"触发点地图"

要实现 Trigger，你不能只依赖 try/catch。
真正有效的 Trigger 来自一套触发点体系——让错误在进入重型流程之前就暴露。

触发点无处不在：

- **运行前**：dev 之前先过门禁，环境/配置/版本能挡的全挡
- **开发中**：文件变更就触发检测，命中已知坑位直接回放
- **合入前**：PR 上跑触发器，失败就输出 TRAV，坑止步于主干之外
- **运行时**：关键路径做契约检查，让"不可见的错"变成可判定信号
- **变更关联**：改了 A 文件就必须检测 B（改 schema → 必跑迁移检查）

> Trigger 的本质是：把隐含关联规则显式化。
> 让"你以为没事"的那一步，在门禁里立刻被拦下来。

---

## 8. 经验回放不是“提示”，而是一份可执行的自愈路径

当 Trigger 触发后，经验系统要输出的不是一句话，而是一段可收敛的路径。

一个合格的经验回放，至少包含：

* 上次的关键状态（State Snapshot）
* 违反的约束（Gap/Invariant）
* 下一步意图（Next Intent，必须受限可收敛）
* 校验方式（Verify）

这里的 “下一步意图” 不一定是命令，它可以是五个层级中的任何一种：

* **L0 直接执行**：run script / apply fix
* **L1 定向阅读**：读指定文档的指定段落
* **L2 受限探索**：只在某目录搜索某关键字，列出候选原因
* **L3 引导变换**：在指定范围做 search/regex replace
* **L4 工具生成**：先生成诊断工具或迁移工具，再执行

关键不是“要不要思考”，而是：

> **让 Agent 不在错误的地方思考。**
> 思考可以，但必须被圈定范围，必须能收敛。

---

## 9. 真正牛逼的代码库，不是“干净”，而是“怕疼”

以前我们评价项目好不好，看：

* 结构清不清晰
* 抽象美不美
* 代码干不干净

这些当然重要。但在 Agent 时代，还有一个新指标更致命：

> **它怕不怕疼？**

所谓“怕疼”，就是：

* 同一类错误可以反复发生（现实就是会发生）
* 但每次都能被 Trigger 捕获
* 每次都能触发 Replay
* 每次都能走 Action
* 每次都能 Verify 回到正轨

也就是说：**错误不会消失，但失控会消失。**

这才是“自愈型代码库”。

---

## 10. 我们会得到一个以前没有的东西

当你把这套系统跑起来，会发生一件非常有趣的事：

> 你的代码库会随着 AI 犯错次数的增加，变得越来越稳固。

以前经验存在人脑里，人员一换就蒸发。
现在经验沉淀在 repo 里，版本可追踪，可复用，可演化。

你会第一次拥有一种“工程化成长”。

---

## 最后一句话

别再执迷于怎么调 Prompt 了。

**真正的 FDD，不是让 AI 当下不犯错，而是让项目记住怎么错过。**
当错误被固化为可检测的触发器，当经验能被自动回放并自愈，你就真正进入了 Agent 时代。

---

但这只是一半。

记住过去的错误，叫 **Feedback（反馈）**——从真实 bug 中归纳经验。

还有另一半叫 **Feedforward（前馈）**——在犯错之前就预判到。

AI 有默认路径。当项目的期望与 AI 的默认行为不一致时，它会犯错。如果你能在开发前就识别这些偏差，提前埋下"纠偏器"，那 AI 根本不会走错。

**FDD = Feedback + Feedforward**

一个记住过去，一个预判未来。两条腿走路，才是完整的 Agent 工程。