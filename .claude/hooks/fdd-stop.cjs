#!/usr/bin/env node
/**
 * FDD Stop Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add/init
 *
 * Detects file modifications and prompts Claude to consider recording pitfalls
 */

const fs = require("fs");
const path = require("path");
const os = require("os");

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    processStopHook(JSON.parse(inputData));
  } catch (error) {
    process.exit(0);
  }
});

function processStopHook(input) {
  const sessionId = input.session_id;
  const transcriptPath = input.transcript_path;

  if (!transcriptPath || !fs.existsSync(transcriptPath)) {
    process.exit(0);
  }

  // State file to prevent infinite loops
  const stateFile = path.join(os.tmpdir(), `fdd-stop-${sessionId}.json`);

  let state = { lastPromptedLine: 0 };
  if (fs.existsSync(stateFile)) {
    try {
      state = JSON.parse(fs.readFileSync(stateFile, "utf8"));
    } catch (e) {}
  }

  // Read transcript
  const content = fs.readFileSync(transcriptPath, "utf8");
  const lines = content.trim().split("\n");
  const currentLineCount = lines.length;

  // Skip if already prompted for this position
  if (state.lastPromptedLine >= currentLineCount) {
    process.exit(0);
  }

  // Check only new lines since last prompt
  const newLines = lines.slice(state.lastPromptedLine);
  const modifyTools = ["Edit", "Write", "MultiEdit"];

  let hasModification = false;
  let modifiedFiles = [];

  for (const line of newLines) {
    try {
      const entry = JSON.parse(line);

      if (entry.message?.content) {
        const contents = Array.isArray(entry.message.content)
          ? entry.message.content
          : [entry.message.content];

        for (const c of contents) {
          if (c.type === "tool_use" && modifyTools.includes(c.name)) {
            const filePath = c.input?.file_path;
            if (!filePath) continue;

            // Skip .fdd/ and .claude/ directories (FDD's own files)
            if (filePath.includes("/.fdd/") || filePath.includes("/.claude/")) continue;

            hasModification = true;
            if (!modifiedFiles.includes(filePath)) {
              // Extract relative path for cleaner output
              const cwd = process.cwd();
              const displayPath = filePath.startsWith(cwd)
                ? filePath.slice(cwd.length + 1)
                : filePath;
              modifiedFiles.push(displayPath);
            }
          }
        }
      }
    } catch (e) {}
  }

  // Update state to mark current position as processed
  state.lastPromptedLine = currentLineCount;
  fs.writeFileSync(stateFile, JSON.stringify(state), "utf8");

  if (hasModification) {
    // JSON 输出: decision: block 让 Claude 继续工作
    // reason 给 Claude 看，systemMessage 给用户看
    console.log(JSON.stringify({
      decision: "block",
      reason: `Potential PIT(s) Detected, read: @.claude/skills/fdd/workflows/record.md`
    }));
    process.exit(0);
  } else {
    process.exit(0);  // Silent exit
  }
}
