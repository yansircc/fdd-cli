#!/usr/bin/env node
/**
 * FDD Inject Context Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add
 *
 * PreToolUse hook that injects context before Edit/Write/MultiEdit operations
 * Uses deny + permissionDecisionReason to inject context into Claude's thinking
 */

const fs = require("fs");
const path = require("path");
const { minimatch } = require("minimatch");

const INJECT_CONTEXT_RULES = [
  {
    "pitfallId": "PIT-001",
    "pitfallTitle": "marked.js 渲染需要 sanitize 防止 XSS",
    "pitfallFilename": "pit-001-marked-js-sanitize-xss.md",
    "triggerIndex": 0,
    "whenTouching": [
      "src/commands/ui/**",
      "src/lib/ui/**"
    ],
    "exclude": [],
    "context": "使用 marked.js 渲染用户内容时必须 sanitize，pit 中的 error_snippet 可能包含恶意脚本"
  }
];

// State file to track already-intercepted files (avoid infinite loop)
const STATE_FILE = path.join(__dirname, ".inject-state.json");

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    handlePreToolUse(JSON.parse(inputData));
  } catch (error) {
    // On error, allow the operation to continue
    outputAllow();
  }
});

function handlePreToolUse(data) {
  const toolName = data.tool_name;
  const toolInput = data.tool_input || {};

  // Only process Edit, Write, MultiEdit tools
  if (toolName !== "Edit" && toolName !== "Write" && toolName !== "MultiEdit") {
    outputAllow();
    return;
  }

  const filePath = toolInput.file_path || "";
  if (!filePath) {
    outputAllow();
    return;
  }

  // Normalize file path to relative path
  const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();
  let normalizedPath = filePath.replace(/^\.\//g, "");
  if (path.isAbsolute(normalizedPath)) {
    normalizedPath = path.relative(projectDir, normalizedPath);
  }

  // Find matching rules
  const matchedRules = findMatchingRules(normalizedPath);
  if (matchedRules.length === 0) {
    outputAllow();
    return;
  }

  // Check state - have we already intercepted this file?
  // Using pure path as key (no session isolation - once warned, always remembered)
  const stateKey = normalizedPath;
  const state = loadState();

  if (state[stateKey]) {
    // Already intercepted, allow
    outputAllow();
    return;
  }

  // First interception - record state and deny with context
  state[stateKey] = {
    timestamp: Date.now(),
    tool: toolName,
    pitfallIds: matchedRules.map(r => r.pitfallId)
  };
  saveState(state);

  // Build the context message (inline all context content)
  const contextMessage = buildContextMessage(matchedRules, normalizedPath);

  // Output deny with the context as reason
  outputDeny(contextMessage);
}

function findMatchingRules(filePath) {
  const matched = [];

  for (const rule of INJECT_CONTEXT_RULES) {
    let isMatch = false;

    // Check when_touching patterns
    for (const pattern of rule.whenTouching) {
      if (minimatch(filePath, pattern) || filePath.includes(pattern.replace(/\*\*/g, "").replace(/\*/g, ""))) {
        isMatch = true;
        break;
      }
    }

    if (!isMatch) continue;

    // Check exclude patterns
    const isExcluded = rule.exclude.some(excl => minimatch(filePath, excl));
    if (isExcluded) continue;

    matched.push(rule);
  }

  return matched;
}

function buildContextMessage(rules, filePath) {
  const parts = [];

  parts.push(`[FDD] 编辑 ${filePath} 前请注意以下历史问题:\n`);

  for (const rule of rules) {
    parts.push(`### [${rule.pitfallId}] ${rule.pitfallTitle}\n`);
    parts.push(rule.context);
    parts.push("");
  }

  parts.push("请继续编辑。");

  return parts.join("\n");
}

function outputAllow() {
  const output = {
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "allow"
    }
  };
  console.log(JSON.stringify(output));
  process.exit(0);
}

function outputDeny(reason) {
  const output = {
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "deny",
      permissionDecisionReason: reason
    }
  };
  console.log(JSON.stringify(output));
  process.exit(0);
}

function loadState() {
  try {
    if (fs.existsSync(STATE_FILE)) {
      return JSON.parse(fs.readFileSync(STATE_FILE, "utf8"));
    }
  } catch (e) {}
  return {};
}

function saveState(state) {
  try {
    fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2));
  } catch (e) {}
}
