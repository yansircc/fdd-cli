#!/usr/bin/env node
/**
 * FDD Protect Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add
 *
 * Intercepts Write/Edit tool calls and blocks/warns based on
 * protect rules defined in .fdd/pits/
 */

const { minimatch } = require("minimatch");
const fs = require("fs");
const path = require("path");

const PROTECT_RULES = [
  {
    "pitfallId": "PIT-000",
    "pitfallTitle": "[ç¤ºä¾‹] ä¿æŠ¤ pitfall æ–‡ä»¶ä¸è¢« AI ç›´æŽ¥å†™å…¥",
    "triggerIndex": 0,
    "paths": [
      ".fdd/pits/**"
    ],
    "exclude": [
      "_template.md",
      "pit-000-*.md"
    ],
    "permissions": {
      "create": "deny",
      "update": "allow",
      "delete": "allow"
    },
    "message": "è¯·ä½¿ç”¨ fdd add --json å‘½ä»¤åˆ›å»º pitfallï¼Œè€Œä¸æ˜¯ç›´æŽ¥å†™å…¥æ–‡ä»¶"
  },
  {
    "pitfallId": "PIT-004",
    "pitfallTitle": "AI åº”ä½¿ç”¨ fdd add è€Œä¸æ˜¯ç›´æŽ¥å†™å…¥ .fdd/pits/",
    "triggerIndex": 0,
    "paths": [
      ".fdd/pits/**"
    ],
    "exclude": [],
    "permissions": {
      "create": "deny",
      "update": "deny",
      "delete": "allow"
    },
    "message": "ä½¿ç”¨ fdd add --json åˆ›å»º Pitï¼Œä¸è¦ç›´æŽ¥å†™å…¥æ–‡ä»¶"
  }
];

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => { inputData += chunk; });
process.stdin.on("end", () => {
  try {
    processToolCall(JSON.parse(inputData));
  } catch (error) {
    process.exit(0);
  }
});

function processToolCall(input) {
  const { tool_input } = input;
  const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();

  const filePath = tool_input?.file_path || tool_input?.path || "";
  if (!filePath) {
    outputAllow();
    return;
  }

  // Normalize to relative path
  let relativePath = filePath;
  if (path.isAbsolute(filePath)) {
    relativePath = path.relative(projectDir, filePath);
  }

  const isCreate = !fs.existsSync(path.resolve(projectDir, relativePath));
  const operation = isCreate ? "create" : "update";

  for (const rule of PROTECT_RULES) {
    const matchesPath = rule.paths.some(pattern =>
      minimatch(relativePath, pattern) || minimatch(filePath, pattern)
    );
    if (!matchesPath) continue;

    const isExcluded = rule.exclude.some(pattern =>
      minimatch(relativePath, pattern) || minimatch(filePath, pattern)
    );
    if (isExcluded) continue;

    const permission = rule.permissions[operation];
    if (permission === "deny") {
      const message = rule.message ||
        `[FDD] File "${relativePath}" is protected by ${rule.pitfallId}`;
      outputDeny(`ðŸš« ${message}\n\nOperation: ${operation}\nPitfall: ${rule.pitfallId} - ${rule.pitfallTitle}`);
      return;
    }
  }

  outputAllow();
}

function outputAllow() {
  const output = {
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "allow"
    }
  };
  console.log(JSON.stringify(output));
  process.exit(0);
}

function outputDeny(reason) {
  const output = {
    hookSpecificOutput: {
      hookEventName: "PreToolUse",
      permissionDecision: "deny",
      permissionDecisionReason: reason
    }
  };
  console.log(JSON.stringify(output));
  process.exit(0);
}
