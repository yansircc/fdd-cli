# FDD Interview

> 调用 AskUserQuestionTool 深度访谈 → 厘清想法 → 识别 AI 盲区

## 核心原则

1. **深度优先**：不问显而易见的问题，挖掘用户没想到的
2. **持续追问**：直到所有维度都确认，不留"待定"
3. **精简产出**：不损失信息的前提下，最小化 token 占用

## 流程总览

```
阶段 1: 发散 → stories.md, flows.md
阶段 2: 收敛 → context.md, constraints.md
阶段 3: 确认 → SPEC.md（索引 + Intent + Unresolved）
阶段 4: 评审 → subagent 挑刺（可选，可多轮）
阶段 5: 纠偏 → 识别高代价偏差 → 演绎 Pit
```

---

## 阶段 1: 发散

用户说的是压缩过的。发散 = 解压缩。

### 两个方向

**1. 回溯问题**

用户说的是方案，不是问题。

```
"我要导出 PDF" → 为什么？ → "要发给不用系统的人" → 这才是问题
```

追问"为什么"，直到触及真正要解决的问题。

**2. 展开隐性需求**

| 类型 | 怎么挖 |
|------|--------|
| 知道但没说 | "有什么你觉得显而易见但我可能不知道的？" |
| 不知道自己知道 | 问具体场景，触发回忆 |
| 不知道自己不知道 | 问边界、极端、负面情况 |

### 产出

- `stories.md`：用户故事（只描述目标，不描述实现）
- `flows.md`：核心流程（单行箭头，不用图表）

---

## 阶段 2: 收敛

发散产出无限可能性。收敛 = 取舍 + 承诺。

**取舍必须用户确认，不能 AI 自己决定。**

### 流程

用 AskUserQuestionTool 确认三类承诺：

| 承诺 | 问什么 |
|------|--------|
| 做什么 | "MVP scope 包括哪些？" |
| 不做什么 | "哪些明确不做？" |
| 用什么方式 | "技术选型？tradeoff 接受吗？" |

每个取舍都要让用户选择或确认。

### 产出

用户确认后，写入文档：
- `context.md`：技术决策 + tradeoff 理由
- `constraints.md`：scope + Non-Goals

### 边界

- 不定义实现细节（数据模型、API、代码结构）
- 不捏造数字（无依据的性能指标标注"目标"）

---

## 阶段 3: 确认

发散是打开，收敛是关上，确认是**锁上**。

确认 = 检查点。确保收敛完成，才放行到下一阶段。

### 完成的标志

- 没有"待定"
- 没有矛盾
- 没有遗漏

### 产出

`SPEC.md` = 索引 + 签字画押

写不出索引 = 有东西没完成。

---

## 阶段 4: 评审

阶段 3 完成后，用 AskUserQuestion 询问 [评审] / [跳过]。

用户选择 [评审] 后：

### 1. 启动 subagents

同时启用 3 个 subagent，形成评审团。

```
Task tool:
  subagent_type: general-purpose
  prompt: |
    你是一个挑剔的评审员。
    阅读 .fdd/specs/{feature}/ 下的所有文档。

    任何陈述都是压缩过的，背后有隐含假设。
    你的任务：找出最可能出错的隐含假设。

    什么假设最危险？
    - 反直觉：和常识不一样，容易做错
    - 隐蔽：不说出来就注意不到
    - 高代价：错了很贵

    输出：问题列表（每条展开一个隐含假设并质疑）
```

### 2. 转化为追问

将 subagents 返回的问题列表，逐条用 AskUserQuestion 向用户确认。

### 3. 迭代

根据用户回答更新文档，再次询问 [评审] / [跳过]，循环直到跳过。

---

## 阶段 5: 纠偏

AI 有默认路径（基于训练数据形成的默认行为）。当项目期望与默认路径不一致时，AI 会犯错。

**Pit 是纠偏器**，只在满足以下条件时创建：

```
需要 Pit = 存在偏差 × 代价高
```

- 默认路径就是对的 → 不需要
- 偏差存在但代价小 → 不需要
- 偏差存在且代价高 → 需要

### 流程

**1. 提出候选**

扫描项目，提出候选 Pit 列表。

**2. 启动否定者**

```
Task tool:
  subagent_type: general-purpose
  prompt: |
    你是否定者。对每个候选 Pit，尝试否定它。

    否定成功的标准：
    - "文档写清楚了 AI 就不会错" → 不是偏差，是需求
    - "这是实现细节" → 不该在规划阶段
    - "错了代价很小" → 不值得创建 Pit
    - "AI 默认就会做对" → 不存在偏差

    候选列表：
    {候选 Pit 列表}

    输出：对每个候选，给出 [否定成功/否定失败] + 理由
```

**3. 只保留否定失败的**

否定成功 → 丢弃
否定失败 → 用 AskUserQuestion 让用户最终确认是否创建

确认后，按 [record.md](record.md) 流程创建演绎 Pit。

**4. 更新 SPEC.md 关联**

每创建一个 Pit，必须同步更新 `SPEC.md` 的 `## Related Pits` 表格：

```markdown
| Pit | 纠正什么 |
|-----|----------|
| [pit-name](../../pits/pit-name.json) | 简述偏差 |
```

---

## 产出规范

### 文档结构

```
.fdd/specs/{feature}/
├── SPEC.md         # 索引
├── stories.md      # 用户故事（目标，不是实现）
├── flows.md        # 核心流程（单行箭头）
├── context.md      # 技术决策 + tradeoff
└── constraints.md  # scope + Non-Goals
```

### 文档的本质

文档是给 AI 读的 context。两个原则：

**1. 信息密度最大化**

token 有限。同样的信息，用最少的 token 表达。

| 做 | 不做 |
|-----|------|
| 表格 | 长段落 |
| 单行箭头 `A → B → C` | Mermaid/ASCII 图 |
| 省略显而易见的 | 解释常识 |

**2. 只记录决策，不记录实现**

文档描述"做什么"和"为什么"，不描述"怎么做"。

| 属于决策 | 属于实现 |
|----------|----------|
| 用 PostgreSQL（因为需要 ACID） | 数据模型定义 |
| 支持离线模式 | API 结构 |
| 不做多租户 | 代码结构 |
